c
@project.save
@project.errors
@project.update(project_params)
c
tasks.where.not(status: "completed").exists?
status == 'completed'
c
if status == 'completed'
   37:       if tasks.where.not(status: "completed").exists?
   38:         errors.add(:status, " of tasks must be completed first")
   39:       end
   40:     end
status == 'completed'
if status == 'completed'
c
errors.add(:status, " of tasks must be completed first") if tasks.where.not(status: "completed").exists?
tasks.where.not(status: "completed").exists?
status == 'completed'
c
@dev_id.email
@dev_id = developer_id
@dev_id
developer_id
@dev_id
c
self.developers
c
self.developers
c
token
c
token
c
dev_ids.blank?
c
dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)
dev_ids = params.dig(:project, :developer_ids)
c
unless @developers.any?; end;
unless @developers.any? end
unless @developers.any?; end
unless @developers.any?
@developers.any?
@developers
n
dev_ids.nil?
dev_ids = params.dig(:project, :developer_ids)
dev_ids.nil?
params.dig(:project, :developer_ids)
   63: 
dev_ids
c
dev_ids
@developers
n
flash[:alert]
dev_ids.nil?
c
@developers
dev_ids.present?
dev_ids
c
@current_user.projects.new(project_params)
projects
@current_user
@project
render :new
status: :unprocessable_entity
redirect_to
@project.developer_ids
c
@project.developer_ids = params.dig(:project, :developer_ids)
params.dig(:project, :developer_ids)
params
@project
params[:project]
@project.developer_ids
c
token
JWT.decode(token, SECRET_KEY)[0]
decoded = JWT.decode(token, SECRET_KEY)[0]
decoded
n
SECRET_KEY
payload[:exp] = exp.to_i
payload
c
send_project_notification
after_create
c
@projects = @current_user.project
c
@current_user
c
@current_user
c
@current_user
c
@current_user
c
@current_user
c
@current_user
@projects
 @current_user.projects
@current_user.is_a?(Manager)
@current_user
