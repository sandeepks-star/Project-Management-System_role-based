c
@current_user.projects.all_completed_projects
@current_user.projects.all_in_progress_projects
@current_user.projects.all_pending_projects
@current_user.projects
c
@current_user.@projects.pending
@current_user.Project.pending
@current_user.projects.pending
@current_user.projects
c
@current_user.projects
Project.where(status: "pending")
self.projects
projects.pending
c
all_pending_projects
@current_user.all_pending_projects
@current_user
@projects
@current_user.projects
c
developer.email
developer
c
job.arguments.first.id
job.arguments.first.first
job.arguments.first
job.arguments
c
developer.email
before_perform_mail_email(*args)
*args
c
job.arguments
c
job.arguments
c
projects
projects.present?
projects.empty?
projects = Project.where(end_date: Date.tomorrow)
c
developer.email
project
developer
q
c
dev = Developer.find(developer_id)
dev
Developer.find(developer_id.id)
developer_id
q
Developer.find(developer_id)
developer_id
c
@dev_id.email
developer_id
c
project
developer
c
@project.save
@project.errors
@project.update(project_params)
c
tasks.where.not(status: "completed").exists?
status == 'completed'
c
if status == 'completed'
   37:       if tasks.where.not(status: "completed").exists?
   38:         errors.add(:status, " of tasks must be completed first")
   39:       end
   40:     end
status == 'completed'
if status == 'completed'
c
errors.add(:status, " of tasks must be completed first") if tasks.where.not(status: "completed").exists?
tasks.where.not(status: "completed").exists?
status == 'completed'
c
@dev_id.email
@dev_id = developer_id
@dev_id
developer_id
@dev_id
c
self.developers
c
self.developers
c
token
c
token
c
dev_ids.blank?
c
dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)
dev_ids = params.dig(:project, :developer_ids)
c
unless @developers.any?; end;
unless @developers.any? end
unless @developers.any?; end
unless @developers.any?
@developers.any?
@developers
n
dev_ids.nil?
dev_ids = params.dig(:project, :developer_ids)
dev_ids.nil?
params.dig(:project, :developer_ids)
   63: 
dev_ids
c
dev_ids
@developers
n
flash[:alert]
dev_ids.nil?
c
@developers
dev_ids.present?
dev_ids
c
@current_user.projects.new(project_params)
projects
@current_user
@project
render :new
status: :unprocessable_entity
redirect_to
@project.developer_ids
c
@project.developer_ids = params.dig(:project, :developer_ids)
params.dig(:project, :developer_ids)
params
@project
params[:project]
@project.developer_ids
c
token
JWT.decode(token, SECRET_KEY)[0]
decoded = JWT.decode(token, SECRET_KEY)[0]
decoded
n
SECRET_KEY
payload[:exp] = exp.to_i
payload
c
send_project_notification
after_create
c
@projects = @current_user.project
c
@current_user
c
@current_user
c
@current_user
c
@current_user
c
@current_user
c
@current_user
@projects
 @current_user.projects
@current_user.is_a?(Manager)
@current_user
dev.email
c
@dev_id.email
developer_id
c
project
developer
c
@project.save
@project.errors
@project.update(project_params)
c
tasks.where.not(status: "completed").exists?
status == 'completed'
c
if status == 'completed'
   37:       if tasks.where.not(status: "completed").exists?
   38:         errors.add(:status, " of tasks must be completed first")
   39:       end
   40:     end
status == 'completed'
if status == 'completed'
c
errors.add(:status, " of tasks must be completed first") if tasks.where.not(status: "completed").exists?
tasks.where.not(status: "completed").exists?
status == 'completed'
c
@dev_id.email
@dev_id = developer_id
@dev_id
developer_id
@dev_id
c
self.developers
c
self.developers
c
token
c
token
c
dev_ids.blank?
c
dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)dev_ids = params.dig(:project, :developer_ids)
dev_ids = params.dig(:project, :developer_ids)
c
unless @developers.any?; end;
unless @developers.any? end
unless @developers.any?; end
unless @developers.any?
@developers.any?
@developers
n
dev_ids.nil?
dev_ids = params.dig(:project, :developer_ids)
dev_ids.nil?
params.dig(:project, :developer_ids)
   63: 
dev_ids
c
dev_ids
@developers
n
flash[:alert]
dev_ids.nil?
c
@developers
dev_ids.present?
dev_ids
c
@current_user.projects.new(project_params)
projects
@current_user
@project
render :new
status: :unprocessable_entity
redirect_to
@project.developer_ids
c
@project.developer_ids = params.dig(:project, :developer_ids)
params.dig(:project, :developer_ids)
params
@project
params[:project]
@project.developer_ids
c
token
